{"ast":null,"code":"'use strict';\n\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { logger } from \"../../common\";\nexport function checkIfConfigIsValid(config) {\n  'worklet';\n\n  var _config$clamp, _config$clamp2;\n  var errorMessage = '';\n  ['stiffness', 'damping', 'dampingRatio', 'mass', 'energyThreshold'].forEach(function (prop) {\n    var value = config[prop];\n    if (value <= 0) {\n      errorMessage += `, ${prop} must be grater than zero but got ${value}`;\n    }\n  });\n  if (config.duration < 0) {\n    errorMessage += `, duration can't be negative, got ${config.duration}`;\n  }\n  if ((_config$clamp = config.clamp) != null && _config$clamp.min && (_config$clamp2 = config.clamp) != null && _config$clamp2.max && config.clamp.min > config.clamp.max) {\n    errorMessage += `, clamp.min should be lower than clamp.max, got clamp: {min: ${config.clamp.min}, max: ${config.clamp.max}} `;\n  }\n  if (errorMessage !== '') {\n    logger.warn('Invalid spring config' + errorMessage);\n  }\n  return errorMessage === '';\n}\nfunction bisectRoot(_ref) {\n  'worklet';\n\n  var min = _ref.min,\n    max = _ref.max,\n    func = _ref.func,\n    precision = _ref.precision,\n    _ref$maxIterations = _ref.maxIterations,\n    maxIterations = _ref$maxIterations === void 0 ? 20 : _ref$maxIterations;\n  var direction = func(max) >= func(min) ? 1 : -1;\n  var idx = maxIterations;\n  var current = (max + min) / 2;\n  while (Math.abs(func(current)) > precision && idx > 0) {\n    idx -= 1;\n    if (func(current) * direction < 0) {\n      min = current;\n    } else {\n      max = current;\n    }\n    current = (min + max) / 2;\n  }\n  return current;\n}\nexport function initialCalculations() {\n  'worklet';\n\n  var stiffness = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var config = arguments.length > 1 ? arguments[1] : undefined;\n  if (config.skipAnimation) {\n    return {\n      zeta: 0,\n      omega0: 0,\n      omega1: 0\n    };\n  }\n  if (config.useDuration) {\n    var m = config.mass,\n      zeta = config.dampingRatio;\n    var omega0 = Math.sqrt(stiffness / m);\n    var omega1 = omega0 * Math.sqrt(1 - zeta ** 2);\n    return {\n      zeta: zeta,\n      omega0: omega0,\n      omega1: omega1\n    };\n  } else {\n    var c = config.damping,\n      _m = config.mass,\n      k = config.stiffness;\n    var _zeta = c / (2 * Math.sqrt(k * _m));\n    var _omega = Math.sqrt(k / _m);\n    var _omega2 = _omega * Math.sqrt(1 - _zeta ** 2);\n    return {\n      zeta: _zeta,\n      omega0: _omega,\n      omega1: _omega2\n    };\n  }\n}\nexport function scaleZetaToMatchClamps(animation, clamp) {\n  'worklet';\n\n  var zeta = animation.zeta,\n    toValue = animation.toValue,\n    startValue = animation.startValue;\n  var toValueNum = Number(toValue);\n  if (startValue === 0) {\n    return zeta;\n  }\n  var _ref2 = startValue <= 0 ? [clamp.min, clamp.max] : [clamp.max, clamp.min],\n    _ref3 = _slicedToArray(_ref2, 2),\n    firstBound = _ref3[0],\n    secondBound = _ref3[1];\n  var relativeExtremum1 = secondBound !== undefined ? Math.abs((secondBound - toValueNum) / startValue) : undefined;\n  var relativeExtremum2 = firstBound !== undefined ? Math.abs((firstBound - toValueNum) / startValue) : undefined;\n  var newZeta1 = relativeExtremum1 !== undefined ? Math.abs(Math.log(relativeExtremum1) / Math.PI) : undefined;\n  var newZeta2 = relativeExtremum2 !== undefined ? Math.abs(Math.log(relativeExtremum2) / (2 * Math.PI)) : undefined;\n  var zetaSatisfyingClamp = [newZeta1, newZeta2].filter(function (x) {\n    return x !== undefined;\n  });\n  return Math.max.apply(Math, _toConsumableArray(zetaSatisfyingClamp).concat([zeta]));\n}\nexport function getEnergy(displacement, velocity, stiffness, mass) {\n  'worklet';\n\n  var potentialEnergy = 0.5 * stiffness * displacement ** 2;\n  var kineticEnergy = 0.5 * mass * velocity ** 2;\n  return potentialEnergy + kineticEnergy;\n}\nexport function calculateNewStiffnessToMatchDuration(x0, config, v0) {\n  'worklet';\n\n  if (config.skipAnimation) {\n    return 0;\n  }\n  var zeta = config.dampingRatio,\n    threshold = config.energyThreshold,\n    m = config.mass,\n    targetDuration = config.duration;\n  var energyDiffForStiffness = function energyDiffForStiffness(stiffness) {\n    'worklet';\n\n    var perceptualCoefficient = 1.5;\n    var MILLISECONDS_IN_SECOND = 1000;\n    var settlingDuration = targetDuration * perceptualCoefficient / MILLISECONDS_IN_SECOND;\n    var omega0 = Math.sqrt(stiffness / m) * zeta;\n    var xtk = (x0 + (v0 + x0 * omega0) * settlingDuration) * Math.exp(-omega0 * settlingDuration);\n    var vtk = (x0 + (v0 + x0 * omega0) * settlingDuration) * Math.exp(-omega0 * settlingDuration) * -omega0 + (v0 + x0 * omega0) * Math.exp(-omega0 * settlingDuration);\n    var e0 = getEnergy(x0, v0, stiffness, m);\n    var etk = getEnergy(xtk, vtk, stiffness, m);\n    var energyFraction = etk / e0;\n    return energyFraction - threshold;\n  };\n  var precision = config.energyThreshold * 1e-3;\n  return bisectRoot({\n    min: Number.EPSILON,\n    max: 8e3,\n    func: energyDiffForStiffness,\n    precision: precision,\n    maxIterations: 100\n  });\n}\nexport function criticallyDampedSpringCalculations(animation, precalculatedValues) {\n  'worklet';\n\n  var toValue = animation.toValue;\n  var v0 = precalculatedValues.v0,\n    x0 = precalculatedValues.x0,\n    omega0 = precalculatedValues.omega0,\n    t = precalculatedValues.t;\n  var criticallyDampedEnvelope = Math.exp(-omega0 * t);\n  var criticallyDampedPosition = toValue + criticallyDampedEnvelope * (x0 + (v0 + omega0 * x0) * t);\n  var criticallyDampedVelocity = criticallyDampedEnvelope * -omega0 * (x0 + (v0 + omega0 * x0) * t) + criticallyDampedEnvelope * (v0 + omega0 * x0);\n  return {\n    position: criticallyDampedPosition,\n    velocity: criticallyDampedVelocity\n  };\n}\nexport function underDampedSpringCalculations(animation, precalculatedValues) {\n  'worklet';\n\n  var toValue = animation.toValue;\n  var zeta = precalculatedValues.zeta,\n    t = precalculatedValues.t,\n    omega0 = precalculatedValues.omega0,\n    omega1 = precalculatedValues.omega1,\n    x0 = precalculatedValues.x0,\n    v0 = precalculatedValues.v0;\n  var sin1 = Math.sin(omega1 * t);\n  var cos1 = Math.cos(omega1 * t);\n  var underDampedEnvelope = Math.exp(-zeta * omega0 * t);\n  var underDampedFrag1 = underDampedEnvelope * (sin1 * ((v0 + zeta * omega0 * x0) / omega1) + x0 * cos1);\n  var underDampedPosition = toValue + underDampedFrag1;\n  var underDampedVelocity = -zeta * omega0 * underDampedFrag1 + underDampedEnvelope * (cos1 * (v0 + zeta * omega0 * x0) - omega1 * x0 * sin1);\n  return {\n    position: underDampedPosition,\n    velocity: underDampedVelocity\n  };\n}\nexport function isAnimationTerminatingCalculation(animation, config) {\n  'worklet';\n\n  var toValue = animation.toValue,\n    velocity = animation.velocity,\n    startValue = animation.startValue,\n    current = animation.current,\n    initialEnergy = animation.initialEnergy;\n  if (config.overshootClamping) {\n    var leftBound = startValue >= 0 ? toValue : toValue + startValue;\n    var rightBound = leftBound + Math.abs(startValue);\n    if (current < leftBound || current > rightBound) {\n      return true;\n    }\n  }\n  var currentEnergy = getEnergy(toValue - current, velocity, config.stiffness, config.mass);\n  return initialEnergy === 0 || currentEnergy / initialEnergy <= config.energyThreshold;\n}","map":{"version":3,"names":["_toConsumableArray","_slicedToArray","logger","checkIfConfigIsValid","config","_config$clamp","_config$clamp2","errorMessage","forEach","prop","value","duration","clamp","min","max","warn","bisectRoot","_ref","func","precision","_ref$maxIterations","maxIterations","direction","idx","current","Math","abs","initialCalculations","stiffness","arguments","length","undefined","skipAnimation","zeta","omega0","omega1","useDuration","m","mass","dampingRatio","sqrt","c","damping","k","scaleZetaToMatchClamps","animation","toValue","startValue","toValueNum","Number","_ref2","_ref3","firstBound","secondBound","relativeExtremum1","relativeExtremum2","newZeta1","log","PI","newZeta2","zetaSatisfyingClamp","filter","x","apply","concat","getEnergy","displacement","velocity","potentialEnergy","kineticEnergy","calculateNewStiffnessToMatchDuration","x0","v0","threshold","energyThreshold","targetDuration","energyDiffForStiffness","perceptualCoefficient","MILLISECONDS_IN_SECOND","settlingDuration","xtk","exp","vtk","e0","etk","energyFraction","EPSILON","criticallyDampedSpringCalculations","precalculatedValues","t","criticallyDampedEnvelope","criticallyDampedPosition","criticallyDampedVelocity","position","underDampedSpringCalculations","sin1","sin","cos1","cos","underDampedEnvelope","underDampedFrag1","underDampedPosition","underDampedVelocity","isAnimationTerminatingCalculation","initialEnergy","overshootClamping","leftBound","rightBound","currentEnergy"],"sources":["C:\\Users\\User\\Desktop\\Atividade1-Desenvolvimento-Mobile-8-6--Periodo\\backend\\node_modules\\react-native-reanimated\\src\\animation\\spring\\springUtils.ts"],"sourcesContent":["'use strict';\nimport { logger } from '../../common';\nimport type { AnimatableValue, Animation, Timestamp } from '../../commonTypes';\nimport type { SpringConfig } from './springConfigs';\n\n// This type contains all the properties from SpringConfig, which are changed to be required,\n// except for optional 'reduceMotion' and 'clamp'\nexport type DefaultSpringConfig = {\n  [K in keyof Required<SpringConfig>]: K extends 'reduceMotion' | 'clamp'\n    ? Required<SpringConfig>[K] | undefined\n    : Required<SpringConfig>[K];\n};\nexport type WithSpringConfig = SpringConfig;\n\nexport interface SpringConfigInner {\n  useDuration: boolean;\n  skipAnimation: boolean;\n}\n\nexport interface SpringAnimation extends Animation<SpringAnimation> {\n  current: AnimatableValue;\n  toValue: AnimatableValue;\n  velocity: number;\n  lastTimestamp: Timestamp;\n  startTimestamp: Timestamp;\n  startValue: number;\n  zeta: number;\n  omega0: number;\n  omega1: number;\n  initialEnergy: number;\n}\n\nexport interface InnerSpringAnimation\n  extends Omit<SpringAnimation, 'toValue' | 'current'> {\n  toValue: number;\n  current: number;\n}\nexport function checkIfConfigIsValid(config: DefaultSpringConfig): boolean {\n  'worklet';\n  let errorMessage = '';\n  (\n    ['stiffness', 'damping', 'dampingRatio', 'mass', 'energyThreshold'] as const\n  ).forEach((prop) => {\n    const value = config[prop];\n    if (value <= 0) {\n      errorMessage += `, ${prop} must be grater than zero but got ${value}`;\n    }\n  });\n\n  if (config.duration < 0) {\n    errorMessage += `, duration can't be negative, got ${config.duration}`;\n  }\n\n  if (\n    config.clamp?.min &&\n    config.clamp?.max &&\n    config.clamp.min > config.clamp.max\n  ) {\n    errorMessage += `, clamp.min should be lower than clamp.max, got clamp: {min: ${config.clamp.min}, max: ${config.clamp.max}} `;\n  }\n\n  if (errorMessage !== '') {\n    logger.warn('Invalid spring config' + errorMessage);\n  }\n\n  return errorMessage === '';\n}\n\nfunction bisectRoot({\n  min,\n  max,\n  func,\n  precision,\n  maxIterations = 20,\n}: {\n  min: number;\n  max: number;\n  func: (x: number) => number;\n  precision: number;\n  maxIterations?: number;\n}) {\n  'worklet';\n  const direction = func(max) >= func(min) ? 1 : -1;\n  let idx = maxIterations;\n  let current = (max + min) / 2;\n  while (Math.abs(func(current)) > precision && idx > 0) {\n    idx -= 1;\n\n    if (func(current) * direction < 0) {\n      min = current;\n    } else {\n      max = current;\n    }\n    current = (min + max) / 2;\n  }\n  return current;\n}\n\nexport function initialCalculations(\n  stiffness = 0,\n  config: DefaultSpringConfig & SpringConfigInner\n): {\n  zeta: number;\n  omega0: number;\n  omega1: number;\n} {\n  'worklet';\n\n  if (config.skipAnimation) {\n    return { zeta: 0, omega0: 0, omega1: 0 };\n  }\n\n  if (config.useDuration) {\n    const { mass: m, dampingRatio: zeta } = config;\n\n    /**\n     * Omega0 and omega1 denote angular frequency and natural angular frequency,\n     * see this link for formulas:\n     * https://courses.lumenlearning.com/suny-osuniversityphysics/chapter/15-5-damped-oscillations/\n     */\n    const omega0 = Math.sqrt(stiffness / m);\n    const omega1 = omega0 * Math.sqrt(1 - zeta ** 2);\n\n    return { zeta, omega0, omega1 };\n  } else {\n    const { damping: c, mass: m, stiffness: k } = config;\n\n    const zeta = c / (2 * Math.sqrt(k * m)); // damping ratio\n    const omega0 = Math.sqrt(k / m); // undamped angular frequency of the oscillator (rad/ms)\n    const omega1 = omega0 * Math.sqrt(1 - zeta ** 2); // exponential decay\n\n    return { zeta, omega0, omega1 };\n  }\n}\n\n/**\n * We make an assumption that we can manipulate zeta without changing duration\n * of movement. According to theory this change is small and tests shows that we\n * can indeed ignore it.\n */\nexport function scaleZetaToMatchClamps(\n  animation: SpringAnimation,\n  clamp: { min?: number; max?: number }\n): number {\n  'worklet';\n  const { zeta, toValue, startValue } = animation;\n  const toValueNum = Number(toValue);\n\n  if (startValue === 0) {\n    return zeta;\n  }\n\n  const [firstBound, secondBound] =\n    startValue <= 0 ? [clamp.min, clamp.max] : [clamp.max, clamp.min];\n\n  /**\n   * The extrema we get from equation below are relative (we obtain a ratio), To\n   * get absolute extrema we convert it as follows:\n   *\n   * AbsoluteExtremum = startValue ± RelativeExtremum * (toValue - startValue)\n   * Where ± denotes:\n   *\n   * - If extremum is over the target\n   * - Otherwise\n   */\n\n  const relativeExtremum1 =\n    secondBound !== undefined\n      ? Math.abs((secondBound - toValueNum) / startValue)\n      : undefined;\n\n  const relativeExtremum2 =\n    firstBound !== undefined\n      ? Math.abs((firstBound - toValueNum) / startValue)\n      : undefined;\n\n  /**\n   * Use this formula http://hyperphysics.phy-astr.gsu.edu/hbase/oscda.html to\n   * calculate first two extrema. These extrema are located where cos = +- 1\n   *\n   * Therefore the first two extrema are:\n   *\n   *     Math.exp(-zeta * Math.PI);      (over the target)\n   *     Math.exp(-zeta * 2 * Math.PI);  (before the target)\n   */\n\n  const newZeta1 =\n    relativeExtremum1 !== undefined\n      ? Math.abs(Math.log(relativeExtremum1) / Math.PI)\n      : undefined;\n\n  const newZeta2 =\n    relativeExtremum2 !== undefined\n      ? Math.abs(Math.log(relativeExtremum2) / (2 * Math.PI))\n      : undefined;\n\n  const zetaSatisfyingClamp = [newZeta1, newZeta2].filter(\n    (x: number | undefined): x is number => x !== undefined\n  );\n  // The bigger is zeta the smaller are bounces, we return the biggest one\n  // because it should satisfy all conditions\n  return Math.max(...zetaSatisfyingClamp, zeta);\n}\n\nexport function getEnergy(\n  displacement: number,\n  velocity: number,\n  stiffness: number,\n  mass: number\n) {\n  'worklet';\n  const potentialEnergy = 0.5 * stiffness * displacement ** 2;\n  const kineticEnergy = 0.5 * mass * velocity ** 2;\n  return potentialEnergy + kineticEnergy;\n}\n\n/** Runs before initial */\nexport function calculateNewStiffnessToMatchDuration(\n  x0: number,\n  config: DefaultSpringConfig & SpringConfigInner,\n  v0: number\n) {\n  'worklet';\n  if (config.skipAnimation) {\n    return 0;\n  }\n\n  /**\n   * Use this formula:\n   * https://phys.libretexts.org/Bookshelves/University_Physics/Book%3A_University_Physics_(OpenStax)/Book%3A_University_Physics_I_-_Mechanics_Sound_Oscillations_and_Waves_(OpenStax)/15%3A_Oscillations/15.06%3A_Damped_Oscillations\n   * to find the asymptote and estimate the damping that gives us the expected\n   * duration\n   *\n   *             ⎛ ⎛ c⎞           ⎞\n   *             ⎜-⎜──⎟ ⋅ duration⎟\n   *             ⎝ ⎝2m⎠           ⎠\n   *        A ⋅ e                   = threshold\n   */\n  const {\n    dampingRatio: zeta,\n    energyThreshold: threshold,\n    mass: m,\n    duration: targetDuration,\n  } = config;\n\n  const energyDiffForStiffness = (stiffness: number) => {\n    'worklet';\n    const perceptualCoefficient = 1.5;\n    const MILLISECONDS_IN_SECOND = 1000;\n\n    const settlingDuration =\n      (targetDuration * perceptualCoefficient) / MILLISECONDS_IN_SECOND;\n    const omega0 = Math.sqrt(stiffness / m) * zeta;\n\n    const xtk =\n      (x0 + (v0 + x0 * omega0) * settlingDuration) *\n      Math.exp(-omega0 * settlingDuration);\n\n    const vtk =\n      (x0 + (v0 + x0 * omega0) * settlingDuration) *\n        Math.exp(-omega0 * settlingDuration) *\n        -omega0 +\n      (v0 + x0 * omega0) * Math.exp(-omega0 * settlingDuration);\n\n    const e0 = getEnergy(x0, v0, stiffness, m);\n\n    const etk = getEnergy(xtk, vtk, stiffness, m);\n\n    const energyFraction = etk / e0;\n\n    return energyFraction - threshold;\n  };\n\n  const precision = config.energyThreshold * 1e-3; // Experimentally seems to be good enough.\n\n  // Bisection turns out to be much faster than Newton's method in our case\n  return bisectRoot({\n    min: Number.EPSILON,\n    max: 8e3 /* Stiffness for 8ms animation doesn't exceed 2e3, we add some safety margin on top of that. */,\n    func: energyDiffForStiffness,\n    precision,\n    maxIterations: 100,\n  });\n}\n\nexport function criticallyDampedSpringCalculations(\n  animation: InnerSpringAnimation,\n  precalculatedValues: {\n    v0: number;\n    x0: number;\n    omega0: number;\n    t: number;\n  }\n): { position: number; velocity: number } {\n  'worklet';\n  const { toValue } = animation;\n\n  const { v0, x0, omega0, t } = precalculatedValues;\n\n  const criticallyDampedEnvelope = Math.exp(-omega0 * t);\n  const criticallyDampedPosition =\n    toValue + criticallyDampedEnvelope * (x0 + (v0 + omega0 * x0) * t);\n\n  const criticallyDampedVelocity =\n    criticallyDampedEnvelope * -omega0 * (x0 + (v0 + omega0 * x0) * t) +\n    criticallyDampedEnvelope * (v0 + omega0 * x0);\n\n  return {\n    position: criticallyDampedPosition,\n    velocity: criticallyDampedVelocity,\n  };\n}\n\nexport function underDampedSpringCalculations(\n  animation: InnerSpringAnimation,\n  precalculatedValues: {\n    zeta: number;\n    v0: number;\n    x0: number;\n    omega0: number;\n    omega1: number;\n    t: number;\n  }\n): { position: number; velocity: number } {\n  'worklet';\n  const { toValue } = animation;\n\n  const { zeta, t, omega0, omega1, x0, v0 } = precalculatedValues;\n\n  const sin1 = Math.sin(omega1 * t);\n  const cos1 = Math.cos(omega1 * t);\n\n  // under damped\n  const underDampedEnvelope = Math.exp(-zeta * omega0 * t);\n  const underDampedFrag1 =\n    underDampedEnvelope *\n    (sin1 * ((v0 + zeta * omega0 * x0) / omega1) + x0 * cos1);\n\n  const underDampedPosition = toValue + underDampedFrag1;\n  // This looks crazy -- it's actually just the derivative of the oscillation function\n  const underDampedVelocity =\n    -zeta * omega0 * underDampedFrag1 +\n    underDampedEnvelope *\n      (cos1 * (v0 + zeta * omega0 * x0) - omega1 * x0 * sin1);\n\n  return { position: underDampedPosition, velocity: underDampedVelocity };\n}\n\nexport function isAnimationTerminatingCalculation(\n  animation: InnerSpringAnimation,\n  config: DefaultSpringConfig & SpringConfigInner\n): boolean {\n  'worklet';\n  const { toValue, velocity, startValue, current, initialEnergy } = animation;\n\n  if (config.overshootClamping) {\n    const leftBound = startValue >= 0 ? toValue : toValue + startValue;\n    const rightBound = leftBound + Math.abs(startValue);\n    if (current < leftBound || current > rightBound) {\n      return true;\n    }\n  }\n  const currentEnergy = getEnergy(\n    toValue - current,\n    velocity,\n    config.stiffness,\n    config.mass\n  );\n\n  return (\n    initialEnergy === 0 ||\n    currentEnergy / initialEnergy <= config.energyThreshold\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}