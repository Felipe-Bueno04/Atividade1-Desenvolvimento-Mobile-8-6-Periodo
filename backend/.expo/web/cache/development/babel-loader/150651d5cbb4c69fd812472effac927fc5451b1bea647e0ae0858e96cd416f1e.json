{"ast":null,"code":"'use strict';\n\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { IS_JEST, SHOULD_BE_USE_WEB } from \"./PlatformChecker\";\nimport { RuntimeKind } from \"./runtimeKind\";\nimport { createSerializable, makeShareableCloneOnUIRecursive } from \"./serializable\";\nimport { serializableMappingCache } from \"./serializableMappingCache\";\nimport { isWorkletFunction } from \"./workletFunction\";\nimport { WorkletsError } from \"./WorkletsError\";\nimport { WorkletsModule } from \"./WorkletsModule\";\nvar runOnUIQueue = [];\nexport function setupMicrotasks() {\n  'worklet';\n\n  var microtasksQueue = [];\n  var isExecutingMicrotasksQueue = false;\n  global.queueMicrotask = function (callback) {\n    microtasksQueue.push(callback);\n  };\n  global._microtaskQueueFinalizers = [];\n  global.__callMicrotasks = function () {\n    if (isExecutingMicrotasksQueue) {\n      return;\n    }\n    try {\n      isExecutingMicrotasksQueue = true;\n      for (var index = 0; index < microtasksQueue.length; index += 1) {\n        microtasksQueue[index]();\n      }\n      microtasksQueue = [];\n      global._microtaskQueueFinalizers.forEach(function (finalizer) {\n        return finalizer();\n      });\n    } finally {\n      isExecutingMicrotasksQueue = false;\n    }\n  };\n}\nfunction callMicrotasksOnUIThread() {\n  'worklet';\n\n  global.__callMicrotasks();\n}\nexport var callMicrotasks = SHOULD_BE_USE_WEB ? function () {} : callMicrotasksOnUIThread;\nexport function scheduleOnUI(worklet) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  runOnUI(worklet).apply(void 0, args);\n}\nexport function runOnUI(worklet) {\n  if (__DEV__ && !SHOULD_BE_USE_WEB && !isWorkletFunction(worklet) && !worklet.__bundleData) {\n    throw new WorkletsError('`runOnUI` can only be used with worklets.');\n  }\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    if (IS_JEST) {\n      WorkletsModule.scheduleOnUI(createSerializable(function () {\n        'worklet';\n\n        worklet.apply(void 0, args);\n      }));\n      return;\n    }\n    if (__DEV__) {\n      createSerializable(worklet);\n      createSerializable(args);\n    }\n    enqueueUI(worklet, args);\n  };\n}\nif (__DEV__) {\n  function runOnUIWorklet() {\n    'worklet';\n\n    throw new WorkletsError('`runOnUI` cannot be called on the UI runtime. Please call the function synchronously or use `queueMicrotask` or `requestAnimationFrame` instead.');\n  }\n  var serializableRunOnUIWorklet = createSerializable(runOnUIWorklet);\n  serializableMappingCache.set(runOnUI, serializableRunOnUIWorklet);\n}\nexport function runOnUISync(worklet) {\n  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    args[_key3 - 1] = arguments[_key3];\n  }\n  return executeOnUIRuntimeSync(worklet).apply(void 0, args);\n}\nexport function executeOnUIRuntimeSync(worklet) {\n  return function () {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    return WorkletsModule.executeOnUIRuntimeSync(createSerializable(function () {\n      'worklet';\n\n      var result = worklet.apply(void 0, args);\n      return makeShareableCloneOnUIRecursive(result);\n    }));\n  };\n}\nfunction runWorkletOnJS(worklet) {\n  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    args[_key5 - 1] = arguments[_key5];\n  }\n  worklet.apply(void 0, args);\n}\nexport function runOnJS(fun) {\n  'worklet';\n\n  if (SHOULD_BE_USE_WEB || globalThis.__RUNTIME_KIND === RuntimeKind.ReactNative) {\n    return function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return queueMicrotask(args.length ? function () {\n        return fun.apply(void 0, args);\n      } : fun);\n    };\n  }\n  if (isWorkletFunction(fun)) {\n    return function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return runOnJS(runWorkletOnJS).apply(void 0, [fun].concat(args));\n    };\n  }\n  if (fun.__remoteFunction) {\n    fun = fun.__remoteFunction;\n  }\n  var scheduleOnJS = typeof fun === 'function' ? global._scheduleHostFunctionOnJS : global._scheduleRemoteFunctionOnJS;\n  return function () {\n    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n    scheduleOnJS(fun, args.length > 0 ? makeShareableCloneOnUIRecursive(args) : undefined);\n  };\n}\nexport function scheduleOnRN(fun) {\n  'worklet';\n\n  for (var _len9 = arguments.length, args = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n    args[_key9 - 1] = arguments[_key9];\n  }\n  runOnJS(fun).apply(void 0, args);\n}\nexport function runOnUIAsync(worklet) {\n  if (__DEV__ && !SHOULD_BE_USE_WEB && !isWorkletFunction(worklet)) {\n    throw new WorkletsError('`runOnUIAsync` can only be used with worklets.');\n  }\n  return function () {\n    for (var _len0 = arguments.length, args = new Array(_len0), _key0 = 0; _key0 < _len0; _key0++) {\n      args[_key0] = arguments[_key0];\n    }\n    return new Promise(function (resolve) {\n      if (IS_JEST) {\n        WorkletsModule.scheduleOnUI(createSerializable(function () {\n          'worklet';\n\n          worklet.apply(void 0, args);\n        }));\n        return;\n      }\n      if (__DEV__) {\n        createSerializable(worklet);\n        createSerializable(args);\n      }\n      enqueueUI(worklet, args, resolve);\n    });\n  };\n}\nif (__DEV__) {\n  function runOnUIAsyncWorklet() {\n    'worklet';\n\n    throw new WorkletsError('`runOnUIAsync` cannot be called on the UI runtime. Please call the function synchronously or use `queueMicrotask` or `requestAnimationFrame` instead.');\n  }\n  var serializableRunOnUIAsyncWorklet = createSerializable(runOnUIAsyncWorklet);\n  serializableMappingCache.set(runOnUIAsync, serializableRunOnUIAsyncWorklet);\n}\nfunction enqueueUI(worklet, args, resolve) {\n  var job = [worklet, args, resolve];\n  runOnUIQueue.push(job);\n  if (runOnUIQueue.length === 1) {\n    flushUIQueue();\n  }\n}\nfunction flushUIQueue() {\n  queueMicrotask(function () {\n    var queue = runOnUIQueue;\n    runOnUIQueue = [];\n    WorkletsModule.scheduleOnUI(createSerializable(function () {\n      'worklet';\n\n      queue.forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 3),\n          workletFunction = _ref2[0],\n          workletArgs = _ref2[1],\n          jobResolve = _ref2[2];\n        var result = workletFunction.apply(void 0, _toConsumableArray(workletArgs));\n        if (jobResolve) {\n          runOnJS(jobResolve)(result);\n        }\n      });\n      callMicrotasks();\n    }));\n  });\n}\nexport function unstable_eventLoopTask(worklet) {\n  return function () {\n    'worklet';\n\n    worklet.apply(void 0, arguments);\n    callMicrotasks();\n  };\n}","map":{"version":3,"names":["_toConsumableArray","_slicedToArray","IS_JEST","SHOULD_BE_USE_WEB","RuntimeKind","createSerializable","makeShareableCloneOnUIRecursive","serializableMappingCache","isWorkletFunction","WorkletsError","WorkletsModule","runOnUIQueue","setupMicrotasks","microtasksQueue","isExecutingMicrotasksQueue","global","queueMicrotask","callback","push","_microtaskQueueFinalizers","__callMicrotasks","index","length","forEach","finalizer","callMicrotasksOnUIThread","callMicrotasks","scheduleOnUI","worklet","_len","arguments","args","Array","_key","runOnUI","apply","__DEV__","__bundleData","_len2","_key2","enqueueUI","runOnUIWorklet","serializableRunOnUIWorklet","set","runOnUISync","_len3","_key3","executeOnUIRuntimeSync","_len4","_key4","result","runWorkletOnJS","_len5","_key5","runOnJS","fun","globalThis","__RUNTIME_KIND","ReactNative","_len6","_key6","_len7","_key7","concat","__remoteFunction","scheduleOnJS","_scheduleHostFunctionOnJS","_scheduleRemoteFunctionOnJS","_len8","_key8","undefined","scheduleOnRN","_len9","_key9","runOnUIAsync","_len0","_key0","Promise","resolve","runOnUIAsyncWorklet","serializableRunOnUIAsyncWorklet","job","flushUIQueue","queue","_ref","_ref2","workletFunction","workletArgs","jobResolve","unstable_eventLoopTask"],"sources":["C:\\Users\\User\\Desktop\\Atividade1-Desenvolvimento-Mobile-8-6--Periodo\\backend\\node_modules\\react-native-worklets\\src\\threads.ts"],"sourcesContent":["'use strict';\nimport { IS_JEST, SHOULD_BE_USE_WEB } from './PlatformChecker';\nimport { RuntimeKind } from './runtimeKind';\nimport {\n  createSerializable,\n  makeShareableCloneOnUIRecursive,\n} from './serializable';\nimport { serializableMappingCache } from './serializableMappingCache';\nimport { isWorkletFunction } from './workletFunction';\nimport { WorkletsError } from './WorkletsError';\nimport { WorkletsModule } from './WorkletsModule';\nimport type { WorkletFunction, WorkletImport } from './workletTypes';\n\ntype UIJob<Args extends unknown[] = unknown[], ReturnValue = unknown> = [\n  worklet: WorkletFunction<Args, ReturnValue>,\n  args: Args,\n  resolve?: (value: ReturnValue) => void,\n];\n\nlet runOnUIQueue: UIJob[] = [];\n\nexport function setupMicrotasks() {\n  'worklet';\n\n  let microtasksQueue: Array<() => void> = [];\n  let isExecutingMicrotasksQueue = false;\n  global.queueMicrotask = (callback: () => void) => {\n    microtasksQueue.push(callback);\n  };\n  global._microtaskQueueFinalizers = [];\n\n  global.__callMicrotasks = () => {\n    if (isExecutingMicrotasksQueue) {\n      return;\n    }\n    try {\n      isExecutingMicrotasksQueue = true;\n      for (let index = 0; index < microtasksQueue.length; index += 1) {\n        // we use classic 'for' loop because the size of the currentTasks array may change while executing some of the callbacks due to queueMicrotask calls\n        microtasksQueue[index]();\n      }\n      microtasksQueue = [];\n      global._microtaskQueueFinalizers.forEach((finalizer) => finalizer());\n    } finally {\n      isExecutingMicrotasksQueue = false;\n    }\n  };\n}\n\nfunction callMicrotasksOnUIThread() {\n  'worklet';\n  global.__callMicrotasks();\n}\n\nexport const callMicrotasks = SHOULD_BE_USE_WEB\n  ? () => {\n      // on web flushing is a noop as immediates are handled by the browser\n    }\n  : callMicrotasksOnUIThread;\n\n/**\n * Lets you schedule a function to be executed on the [UI\n * Runtime](https://docs.swmansion.com/react-native-worklets/docs/fundamentals/glossary#ui-runtime).\n *\n * - The callback executes asynchronously and doesn't return a value.\n * - Passed function and args are automatically\n *   [workletized](https://docs.swmansion.com/react-native-worklets/docs/fundamentals/glossary#to-workletize)\n *   and serialized.\n * - This function cannot be called from the [UI\n *   Runtime](https://docs.swmansion.com/react-native-worklets/docs/fundamentals/glossary#ui-runtime)\n *   or [Worker\n *   Runtime](https://docs.swmansion.com/react-native-worklets/docs/fundamentals/glossary#worker-worklet-runtime---worker-runtime),\n *   unless you have the [Bundle Mode](/docs/experimental/bundleMode) enabled.\n *\n * @param fun - A reference to a function you want to schedule on the [UI\n *   Runtime](https://docs.swmansion.com/react-native-worklets/docs/fundamentals/glossary#ui-runtime).\n * @param args - Arguments to pass to the function.\n * @see https://docs.swmansion.com/react-native-worklets/docs/threading/scheduleOnUI\n */\nexport function scheduleOnUI<Args extends unknown[], ReturnValue>(\n  worklet: (...args: Args) => ReturnValue,\n  ...args: Args\n): void {\n  runOnUI(worklet)(...args);\n}\n\n/**\n * Lets you asynchronously run\n * [workletized](https://docs.swmansion.com/react-native-worklets/docs/fundamentals/glossary#to-workletize)\n * functions on the [UI\n * thread](https://docs.swmansion.com/react-native-worklets/docs/threading/runOnUI/).\n *\n * This method does not schedule the work immediately but instead waits for\n * other worklets to be scheduled within the same JS loop. It uses\n * queueMicrotask to schedule all the worklets at once making sure they will run\n * within the same frame boundaries on the UI thread.\n *\n * @param fun - A reference to a function you want to execute on the [UI\n *   thread](https://docs.swmansion.com/react-native-worklets/docs/threading/runOnUI/)\n *   from the [JavaScript\n *   thread](https://docs.swmansion.com/react-native-worklets/docs/threading/runOnUI/).\n * @returns A function that accepts arguments for the function passed as the\n *   first argument.\n * @see https://docs.swmansion.com/react-native-worklets/docs/threading/runOnUI @deprecated Use `scheduleOnUI` instead.\n */\n// @ts-expect-error This overload is correct since it's what user sees in his code\n// before it's transformed by Reanimated Babel plugin.\nexport function runOnUI<Args extends unknown[], ReturnValue>(\n  worklet: (...args: Args) => ReturnValue\n): (...args: Args) => void;\n\nexport function runOnUI<Args extends unknown[], ReturnValue>(\n  worklet: WorkletFunction<Args, ReturnValue>\n): (...args: Args) => void {\n  if (\n    __DEV__ &&\n    !SHOULD_BE_USE_WEB &&\n    !isWorkletFunction(worklet) &&\n    !(worklet as unknown as WorkletImport).__bundleData\n  ) {\n    throw new WorkletsError('`runOnUI` can only be used with worklets.');\n  }\n  return (...args) => {\n    if (IS_JEST) {\n      // Mocking time in Jest is tricky as both requestAnimationFrame and queueMicrotask\n      // callbacks run on the same queue and can be interleaved. There is no way\n      // to flush particular queue in Jest and the only control over mocked timers\n      // is by using jest.advanceTimersByTime() method which advances all types\n      // of timers including immediate and animation callbacks. Ideally we'd like\n      // to have some way here to schedule work along with React updates, but\n      // that's not possible, and hence in Jest environment instead of using scheduling\n      // mechanism we just schedule the work ommiting the queue. This is ok for the\n      // uses that we currently have but may not be ok for future tests that we write.\n      WorkletsModule.scheduleOnUI(\n        createSerializable(() => {\n          'worklet';\n          worklet(...args);\n        })\n      );\n      return;\n    }\n    if (__DEV__) {\n      // in DEV mode we call serializable conversion here because in case the object\n      // can't be converted, we will get a meaningful stack-trace as opposed to the\n      // situation when conversion is only done via microtask queue. This does not\n      // make the app particularily less efficient as converted objects are cached\n      // and for a given worklet the conversion only happens once.\n      createSerializable(worklet);\n      createSerializable(args);\n    }\n\n    enqueueUI(worklet, args);\n  };\n}\n\nif (__DEV__) {\n  function runOnUIWorklet(): void {\n    'worklet';\n    throw new WorkletsError(\n      '`runOnUI` cannot be called on the UI runtime. Please call the function synchronously or use `queueMicrotask` or `requestAnimationFrame` instead.'\n    );\n  }\n\n  const serializableRunOnUIWorklet = createSerializable(runOnUIWorklet);\n  serializableMappingCache.set(runOnUI, serializableRunOnUIWorklet);\n}\n\n/**\n * Lets you run a function synchronously on the [UI\n * Runtime](https://docs.swmansion.com/react-native-worklets/docs/fundamentals/glossary#ui-runtime)\n * from the [RN\n * Runtime](https://docs.swmansion.com/react-native-worklets/docs/fundamentals/glossary#react-native-runtime-rn-runtime).\n * Passed function and args are automatically\n * [workletized](https://docs.swmansion.com/react-native-worklets/docs/fundamentals/glossary#to-workletize)\n * and serialized.\n *\n * - This function cannot be called from the [UI\n *   Runtime](https://docs.swmansion.com/react-native-worklets/docs/fundamentals/glossary#ui-runtime).\n * - This function cannot be called from a [Worker\n *   Runtime](https://docs.swmansion.com/react-native-worklets/docs/fundamentals/glossary#worker-worklet-runtime---worker-runtime).\n *\n * @param fun - A reference to a function you want to execute on the [UI\n *   Runtime](https://docs.swmansion.com/react-native-worklets/docs/fundamentals/glossary#ui-runtime).\n * @param args - Arguments to pass to the function.\n * @returns The return value of the function passed as the first argument.\n * @see https://docs.swmansion.com/react-native-worklets/docs/threading/runOnUISync\n */\nexport function runOnUISync<Args extends unknown[], ReturnValue>(\n  worklet: (...args: Args) => ReturnValue,\n  ...args: Args\n): ReturnValue {\n  return executeOnUIRuntimeSync(worklet)(...args);\n}\n\n// @ts-expect-error Check `executeOnUIRuntimeSync` overload above.\nexport function executeOnUIRuntimeSync<Args extends unknown[], ReturnValue>(\n  worklet: (...args: Args) => ReturnValue\n): (...args: Args) => ReturnValue;\n\nexport function executeOnUIRuntimeSync<Args extends unknown[], ReturnValue>(\n  worklet: WorkletFunction<Args, ReturnValue>\n): (...args: Args) => ReturnValue {\n  return (...args) => {\n    return WorkletsModule.executeOnUIRuntimeSync(\n      createSerializable(() => {\n        'worklet';\n        const result = worklet(...args);\n        return makeShareableCloneOnUIRecursive(result);\n      })\n    );\n  };\n}\n\ntype ReleaseRemoteFunction<Args extends unknown[], ReturnValue> = {\n  (...args: Args): ReturnValue;\n};\n\ntype DevRemoteFunction<Args extends unknown[], ReturnValue> = {\n  __remoteFunction: (...args: Args) => ReturnValue;\n};\n\ntype RemoteFunction<Args extends unknown[], ReturnValue> =\n  | ReleaseRemoteFunction<Args, ReturnValue>\n  | DevRemoteFunction<Args, ReturnValue>;\n\nfunction runWorkletOnJS<Args extends unknown[], ReturnValue>(\n  worklet: WorkletFunction<Args, ReturnValue>,\n  ...args: Args\n): void {\n  // remote function that calls a worklet synchronously on the JS runtime\n  worklet(...args);\n}\n\n/**\n * Lets you asynchronously run\n * non-[workletized](https://docs.swmansion.com/react-native-worklets/docs/fundamentals/glossary#to-workletize)\n * functions that couldn't otherwise run on the [UI\n * thread](https://docs.swmansion.com/react-native-worklets/docs/fundamentals/glossary#ui-thread).\n * This applies to most external libraries as they don't have their functions\n * marked with \"worklet\"; directive.\n *\n * @param fun - A reference to a function you want to execute on the JavaScript\n *   thread from the UI thread.\n * @returns A function that accepts arguments for the function passed as the\n *   first argument.\n * @see https://docs.swmansion.com/react-native-worklets/docs/threading/runOnJS\n */\n/** @deprecated Use `scheduleOnRN` instead. */\nexport function runOnJS<Args extends unknown[], ReturnValue>(\n  fun:\n    | ((...args: Args) => ReturnValue)\n    | RemoteFunction<Args, ReturnValue>\n    | WorkletFunction<Args, ReturnValue>\n): (...args: Args) => void {\n  'worklet';\n  type FunDevRemote = Extract<typeof fun, DevRemoteFunction<Args, ReturnValue>>;\n  if (\n    SHOULD_BE_USE_WEB ||\n    globalThis.__RUNTIME_KIND === RuntimeKind.ReactNative\n  ) {\n    // if we are already on the JS thread, we just schedule the worklet on the JS queue\n    return (...args) =>\n      queueMicrotask(\n        args.length\n          ? () => (fun as (...args: Args) => ReturnValue)(...args)\n          : (fun as () => ReturnValue)\n      );\n  }\n  if (isWorkletFunction<Args, ReturnValue>(fun)) {\n    // If `fun` is a worklet, we schedule a call of a remote function `runWorkletOnJS`\n    // and pass the worklet as a first argument followed by original arguments.\n\n    return (...args) =>\n      runOnJS(runWorkletOnJS<Args, ReturnValue>)(\n        fun as WorkletFunction<Args, ReturnValue>,\n        ...args\n      );\n  }\n  if ((fun as FunDevRemote).__remoteFunction) {\n    // In development mode the function provided as `fun` throws an error message\n    // such that when someone accidentally calls it directly on the UI runtime, they\n    // see that they should use `runOnJS` instead. To facilitate that we put the\n    // reference to the original remote function in the `__remoteFunction` property.\n    fun = (fun as FunDevRemote).__remoteFunction;\n  }\n\n  const scheduleOnJS =\n    typeof fun === 'function'\n      ? global._scheduleHostFunctionOnJS\n      : global._scheduleRemoteFunctionOnJS;\n\n  return (...args) => {\n    scheduleOnJS(\n      fun as\n        | ((...args: Args) => ReturnValue)\n        | WorkletFunction<Args, ReturnValue>,\n      args.length > 0 ? makeShareableCloneOnUIRecursive(args) : undefined\n    );\n  };\n}\n\n/**\n * Lets you schedule a function to be executed on the RN runtime from any\n * runtime. Check\n * {@link https://docs.swmansion.com/react-native-worklets/docs/fundamentals/runtimeKinds}\n * for more information about the different runtime kinds.\n *\n * Scheduling function from the RN Runtime (we are already on RN Runtime) simply\n * uses `queueMicrotask`.\n *\n * When functions need to be scheduled from the UI Runtime, first function and\n * args are serialized and then the system passes the scheduling responsibility\n * to the JSScheduler. The JSScheduler then uses the RN CallInvoker to schedule\n * the function asynchronously on the JavaScript thread by calling\n * `jsCallInvoker_->invokeAsync()`.\n *\n * When called from a Worker Runtime, it uses the same JSScheduler mechanism.\n *\n * @param fun - A function you want to schedule on the RN runtime. A function\n *   can be a worklet, a remote function or a regular function.\n * @param args - Arguments to pass to the function.\n * @see https://docs.swmansion.com/react-native-worklets/docs/threading/scheduleOnRN\n */\nexport function scheduleOnRN<Args extends unknown[], ReturnValue>(\n  fun:\n    | ((...args: Args) => ReturnValue)\n    | RemoteFunction<Args, ReturnValue>\n    | WorkletFunction<Args, ReturnValue>,\n  ...args: Args\n): void {\n  'worklet';\n  runOnJS(fun)(...args);\n}\n\n/**\n * Lets you asynchronously run\n * [workletized](https://docs.swmansion.com/react-native-worklets/docs/fundamentals/glossary#to-workletize)\n * functions on the [UI\n * Runtime](https://docs.swmansion.com/react-native-worklets/docs/fundamentals/glossary#ui-runtime).\n *\n * This method does not schedule the work immediately but instead waits for\n * other worklets to be scheduled within the same JS loop. It uses\n * queueMicrotask to schedule all the worklets at once making sure they will run\n * within the same frame boundaries on the UI thread.\n *\n * @param fun - A reference to a function you want to execute on the [UI\n *   Runtime](https://docs.swmansion.com/react-native-worklets/docs/fundamentals/glossary#ui-runtime).\n *   from the [JavaScript\n *   Runtime](https://docs.swmansion.com/react-native-worklets/docs/fundamentals/glossary#javascript-runtime).\n * @returns A promise that resolves to the return value of the function passed\n *   as the first argument.\n * @see https://docs.swmansion.com/react-native-worklets/docs/threading/runOnUIAsync\n */\nexport function runOnUIAsync<Args extends unknown[], ReturnValue>(\n  worklet: (...args: Args) => ReturnValue\n): (...args: Args) => Promise<ReturnValue> {\n  if (__DEV__ && !SHOULD_BE_USE_WEB && !isWorkletFunction(worklet)) {\n    throw new WorkletsError('`runOnUIAsync` can only be used with worklets.');\n  }\n  return (...args: Args) => {\n    return new Promise<ReturnValue>((resolve) => {\n      if (IS_JEST) {\n        // Mocking time in Jest is tricky as both requestAnimationFrame and queueMicrotask\n        // callbacks run on the same queue and can be interleaved. There is no way\n        // to flush particular queue in Jest and the only control over mocked timers\n        // is by using jest.advanceTimersByTime() method which advances all types\n        // of timers including immediate and animation callbacks. Ideally we'd like\n        // to have some way here to schedule work along with React updates, but\n        // that's not possible, and hence in Jest environment instead of using scheduling\n        // mechanism we just schedule the work ommiting the queue. This is ok for the\n        // uses that we currently have but may not be ok for future tests that we write.\n        WorkletsModule.scheduleOnUI(\n          createSerializable(() => {\n            'worklet';\n            worklet(...args);\n          })\n        );\n        return;\n      }\n      if (__DEV__) {\n        // in DEV mode we call serializable conversion here because in case the object\n        // can't be converted, we will get a meaningful stack-trace as opposed to the\n        // situation when conversion is only done via microtask queue. This does not\n        // make the app particularily less efficient as converted objects are cached\n        // and for a given worklet the conversion only happens once.\n        createSerializable(worklet);\n        createSerializable(args);\n      }\n\n      enqueueUI(worklet as WorkletFunction<Args, ReturnValue>, args, resolve);\n    });\n  };\n}\n\nif (__DEV__) {\n  function runOnUIAsyncWorklet(): void {\n    'worklet';\n    throw new WorkletsError(\n      '`runOnUIAsync` cannot be called on the UI runtime. Please call the function synchronously or use `queueMicrotask` or `requestAnimationFrame` instead.'\n    );\n  }\n\n  const serializableRunOnUIAsyncWorklet =\n    createSerializable(runOnUIAsyncWorklet);\n  serializableMappingCache.set(runOnUIAsync, serializableRunOnUIAsyncWorklet);\n}\n\nfunction enqueueUI<Args extends unknown[], ReturnValue>(\n  worklet: WorkletFunction<Args, ReturnValue>,\n  args: Args,\n  resolve?: (value: ReturnValue) => void\n): void {\n  const job = [worklet, args, resolve] as UIJob<Args, ReturnValue>;\n  runOnUIQueue.push(job as unknown as UIJob);\n  if (runOnUIQueue.length === 1) {\n    flushUIQueue();\n  }\n}\n\nfunction flushUIQueue(): void {\n  queueMicrotask(() => {\n    const queue = runOnUIQueue;\n    runOnUIQueue = [];\n    WorkletsModule.scheduleOnUI(\n      createSerializable(() => {\n        'worklet';\n        queue.forEach(([workletFunction, workletArgs, jobResolve]) => {\n          const result = workletFunction(...workletArgs);\n          if (jobResolve) {\n            runOnJS(jobResolve)(result);\n          }\n        });\n        callMicrotasks();\n      })\n    );\n  });\n}\n\n/**\n * Added temporarily for integration with `react-native-audio-api`. Don't depend\n * on this API as it may change without notice.\n */\n// eslint-disable-next-line camelcase\nexport function unstable_eventLoopTask<TArgs extends unknown[], TRet>(\n  worklet: (...args: TArgs) => TRet\n) {\n  return (...args: TArgs) => {\n    'worklet';\n    worklet(...args);\n    callMicrotasks();\n  };\n}\n"],"mappings":"AAAA,YAAY;;AAAA,OAAAA,kBAAA;AAAA,OAAAC,cAAA;AACZ,SAASC,OAAO,EAAEC,iBAAiB;AACnC,SAASC,WAAW;AACpB,SACEC,kBAAkB,EAClBC,+BAA+B;AAEjC,SAASC,wBAAwB;AACjC,SAASC,iBAAiB;AAC1B,SAASC,aAAa;AACtB,SAASC,cAAc;AASvB,IAAIC,YAAqB,GAAG,EAAE;AAE9B,OAAO,SAASC,eAAeA,CAAA,EAAG;EAChC,SAAS;;EAET,IAAIC,eAAkC,GAAG,EAAE;EAC3C,IAAIC,0BAA0B,GAAG,KAAK;EACtCC,MAAM,CAACC,cAAc,GAAI,UAAAC,QAAoB,EAAK;IAChDJ,eAAe,CAACK,IAAI,CAACD,QAAQ,CAAC;EAChC,CAAC;EACDF,MAAM,CAACI,yBAAyB,GAAG,EAAE;EAErCJ,MAAM,CAACK,gBAAgB,GAAG,YAAM;IAC9B,IAAIN,0BAA0B,EAAE;MAC9B;IACF;IACA,IAAI;MACFA,0BAA0B,GAAG,IAAI;MACjC,KAAK,IAAIO,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGR,eAAe,CAACS,MAAM,EAAED,KAAK,IAAI,CAAC,EAAE;QAE9DR,eAAe,CAACQ,KAAK,CAAC,CAAC,CAAC;MAC1B;MACAR,eAAe,GAAG,EAAE;MACpBE,MAAM,CAACI,yBAAyB,CAACI,OAAO,CAAE,UAAAC,SAAS;QAAA,OAAKA,SAAS,CAAC,CAAC;MAAA,EAAC;IACtE,CAAC,SAAS;MACRV,0BAA0B,GAAG,KAAK;IACpC;EACF,CAAC;AACH;AAEA,SAASW,wBAAwBA,CAAA,EAAG;EAClC,SAAS;;EACTV,MAAM,CAACK,gBAAgB,CAAC,CAAC;AAC3B;AAEA,OAAO,IAAMM,cAAc,GAAGvB,iBAAiB,GAC3C,YAAM,CACJ,CACD,GACDsB,wBAAwB;AAqB5B,OAAO,SAASE,YAAYA,CAC1BC,OAAuC,EAEjC;EAAA,SAAAC,IAAA,GAAAC,SAAA,CAAAR,MAAA,EADHS,IAAU,OAAAC,KAAA,CAAAH,IAAA,OAAAA,IAAA,WAAAI,IAAA,MAAAA,IAAA,GAAAJ,IAAA,EAAAI,IAAA;IAAVF,IAAU,CAAAE,IAAA,QAAAH,SAAA,CAAAG,IAAA;EAAA;EAEbC,OAAO,CAACN,OAAO,CAAC,CAAAO,KAAA,SAAIJ,IAAI,CAAC;AAC3B;AA2BA,OAAO,SAASG,OAAOA,CACrBN,OAA2C,EAClB;EACzB,IACEQ,OAAO,IACP,CAACjC,iBAAiB,IAClB,CAACK,iBAAiB,CAACoB,OAAO,CAAC,IAC3B,CAAEA,OAAO,CAA8BS,YAAY,EACnD;IACA,MAAM,IAAI5B,aAAa,CAAC,2CAA2C,CAAC;EACtE;EACA,OAAO,YAAa;IAAA,SAAA6B,KAAA,GAAAR,SAAA,CAAAR,MAAA,EAATS,IAAI,OAAAC,KAAA,CAAAM,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAAJR,IAAI,CAAAQ,KAAA,IAAAT,SAAA,CAAAS,KAAA;IAAA;IACb,IAAIrC,OAAO,EAAE;MAUXQ,cAAc,CAACiB,YAAY,CACzBtB,kBAAkB,CAAC,YAAM;QACvB,SAAS;;QACTuB,OAAO,CAAAO,KAAA,SAAIJ,IAAI,CAAC;MAClB,CAAC,CACH,CAAC;MACD;IACF;IACA,IAAIK,OAAO,EAAE;MAMX/B,kBAAkB,CAACuB,OAAO,CAAC;MAC3BvB,kBAAkB,CAAC0B,IAAI,CAAC;IAC1B;IAEAS,SAAS,CAACZ,OAAO,EAAEG,IAAI,CAAC;EAC1B,CAAC;AACH;AAEA,IAAIK,OAAO,EAAE;EACX,SAASK,cAAcA,CAAA,EAAS;IAC9B,SAAS;;IACT,MAAM,IAAIhC,aAAa,CACrB,kJACF,CAAC;EACH;EAEA,IAAMiC,0BAA0B,GAAGrC,kBAAkB,CAACoC,cAAc,CAAC;EACrElC,wBAAwB,CAACoC,GAAG,CAACT,OAAO,EAAEQ,0BAA0B,CAAC;AACnE;AAsBA,OAAO,SAASE,WAAWA,CACzBhB,OAAuC,EAE1B;EAAA,SAAAiB,KAAA,GAAAf,SAAA,CAAAR,MAAA,EADVS,IAAU,OAAAC,KAAA,CAAAa,KAAA,OAAAA,KAAA,WAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;IAAVf,IAAU,CAAAe,KAAA,QAAAhB,SAAA,CAAAgB,KAAA;EAAA;EAEb,OAAOC,sBAAsB,CAACnB,OAAO,CAAC,CAAAO,KAAA,SAAIJ,IAAI,CAAC;AACjD;AAOA,OAAO,SAASgB,sBAAsBA,CACpCnB,OAA2C,EACX;EAChC,OAAO,YAAa;IAAA,SAAAoB,KAAA,GAAAlB,SAAA,CAAAR,MAAA,EAATS,IAAI,OAAAC,KAAA,CAAAgB,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAAJlB,IAAI,CAAAkB,KAAA,IAAAnB,SAAA,CAAAmB,KAAA;IAAA;IACb,OAAOvC,cAAc,CAACqC,sBAAsB,CAC1C1C,kBAAkB,CAAC,YAAM;MACvB,SAAS;;MACT,IAAM6C,MAAM,GAAGtB,OAAO,CAAAO,KAAA,SAAIJ,IAAI,CAAC;MAC/B,OAAOzB,+BAA+B,CAAC4C,MAAM,CAAC;IAChD,CAAC,CACH,CAAC;EACH,CAAC;AACH;AAcA,SAASC,cAAcA,CACrBvB,OAA2C,EAErC;EAAA,SAAAwB,KAAA,GAAAtB,SAAA,CAAAR,MAAA,EADHS,IAAU,OAAAC,KAAA,CAAAoB,KAAA,OAAAA,KAAA,WAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;IAAVtB,IAAU,CAAAsB,KAAA,QAAAvB,SAAA,CAAAuB,KAAA;EAAA;EAGbzB,OAAO,CAAAO,KAAA,SAAIJ,IAAI,CAAC;AAClB;AAiBA,OAAO,SAASuB,OAAOA,CACrBC,GAGsC,EACb;EACzB,SAAS;;EAET,IACEpD,iBAAiB,IACjBqD,UAAU,CAACC,cAAc,KAAKrD,WAAW,CAACsD,WAAW,EACrD;IAEA,OAAO;MAAA,SAAAC,KAAA,GAAA7B,SAAA,CAAAR,MAAA,EAAIS,IAAI,OAAAC,KAAA,CAAA2B,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAAJ7B,IAAI,CAAA6B,KAAA,IAAA9B,SAAA,CAAA8B,KAAA;MAAA;MAAA,OACb5C,cAAc,CACZe,IAAI,CAACT,MAAM,GACP;QAAA,OAAOiC,GAAG,CAAApB,KAAA,SAAuCJ,IAAI,CAAC;MAAA,IACrDwB,GACP,CAAC;IAAA;EACL;EACA,IAAI/C,iBAAiB,CAAoB+C,GAAG,CAAC,EAAE;IAI7C,OAAO;MAAA,SAAAM,KAAA,GAAA/B,SAAA,CAAAR,MAAA,EAAIS,IAAI,OAAAC,KAAA,CAAA6B,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAAJ/B,IAAI,CAAA+B,KAAA,IAAAhC,SAAA,CAAAgC,KAAA;MAAA;MAAA,OACbR,OAAO,CAACH,cAAiC,CAAC,CAAAhB,KAAA,UACxCoB,GAAG,EAAAQ,MAAA,CACAhC,IACL,EAAC;IAAA;EACL;EACA,IAAKwB,GAAG,CAAkBS,gBAAgB,EAAE;IAK1CT,GAAG,GAAIA,GAAG,CAAkBS,gBAAgB;EAC9C;EAEA,IAAMC,YAAY,GAChB,OAAOV,GAAG,KAAK,UAAU,GACrBxC,MAAM,CAACmD,yBAAyB,GAChCnD,MAAM,CAACoD,2BAA2B;EAExC,OAAO,YAAa;IAAA,SAAAC,KAAA,GAAAtC,SAAA,CAAAR,MAAA,EAATS,IAAI,OAAAC,KAAA,CAAAoC,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAAJtC,IAAI,CAAAsC,KAAA,IAAAvC,SAAA,CAAAuC,KAAA;IAAA;IACbJ,YAAY,CACVV,GAAG,EAGHxB,IAAI,CAACT,MAAM,GAAG,CAAC,GAAGhB,+BAA+B,CAACyB,IAAI,CAAC,GAAGuC,SAC5D,CAAC;EACH,CAAC;AACH;AAwBA,OAAO,SAASC,YAAYA,CAC1BhB,GAGsC,EAEhC;EACN,SAAS;;EAAA,SAAAiB,KAAA,GAAA1C,SAAA,CAAAR,MAAA,EAFNS,IAAU,OAAAC,KAAA,CAAAwC,KAAA,OAAAA,KAAA,WAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;IAAV1C,IAAU,CAAA0C,KAAA,QAAA3C,SAAA,CAAA2C,KAAA;EAAA;EAGbnB,OAAO,CAACC,GAAG,CAAC,CAAApB,KAAA,SAAIJ,IAAI,CAAC;AACvB;AAqBA,OAAO,SAAS2C,YAAYA,CAC1B9C,OAAuC,EACE;EACzC,IAAIQ,OAAO,IAAI,CAACjC,iBAAiB,IAAI,CAACK,iBAAiB,CAACoB,OAAO,CAAC,EAAE;IAChE,MAAM,IAAInB,aAAa,CAAC,gDAAgD,CAAC;EAC3E;EACA,OAAO,YAAmB;IAAA,SAAAkE,KAAA,GAAA7C,SAAA,CAAAR,MAAA,EAAfS,IAAU,OAAAC,KAAA,CAAA2C,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAAV7C,IAAU,CAAA6C,KAAA,IAAA9C,SAAA,CAAA8C,KAAA;IAAA;IACnB,OAAO,IAAIC,OAAO,CAAe,UAAAC,OAAO,EAAK;MAC3C,IAAI5E,OAAO,EAAE;QAUXQ,cAAc,CAACiB,YAAY,CACzBtB,kBAAkB,CAAC,YAAM;UACvB,SAAS;;UACTuB,OAAO,CAAAO,KAAA,SAAIJ,IAAI,CAAC;QAClB,CAAC,CACH,CAAC;QACD;MACF;MACA,IAAIK,OAAO,EAAE;QAMX/B,kBAAkB,CAACuB,OAAO,CAAC;QAC3BvB,kBAAkB,CAAC0B,IAAI,CAAC;MAC1B;MAEAS,SAAS,CAACZ,OAAO,EAAwCG,IAAI,EAAE+C,OAAO,CAAC;IACzE,CAAC,CAAC;EACJ,CAAC;AACH;AAEA,IAAI1C,OAAO,EAAE;EACX,SAAS2C,mBAAmBA,CAAA,EAAS;IACnC,SAAS;;IACT,MAAM,IAAItE,aAAa,CACrB,uJACF,CAAC;EACH;EAEA,IAAMuE,+BAA+B,GACnC3E,kBAAkB,CAAC0E,mBAAmB,CAAC;EACzCxE,wBAAwB,CAACoC,GAAG,CAAC+B,YAAY,EAAEM,+BAA+B,CAAC;AAC7E;AAEA,SAASxC,SAASA,CAChBZ,OAA2C,EAC3CG,IAAU,EACV+C,OAAsC,EAChC;EACN,IAAMG,GAAG,GAAG,CAACrD,OAAO,EAAEG,IAAI,EAAE+C,OAAO,CAA6B;EAChEnE,YAAY,CAACO,IAAI,CAAC+D,GAAuB,CAAC;EAC1C,IAAItE,YAAY,CAACW,MAAM,KAAK,CAAC,EAAE;IAC7B4D,YAAY,CAAC,CAAC;EAChB;AACF;AAEA,SAASA,YAAYA,CAAA,EAAS;EAC5BlE,cAAc,CAAC,YAAM;IACnB,IAAMmE,KAAK,GAAGxE,YAAY;IAC1BA,YAAY,GAAG,EAAE;IACjBD,cAAc,CAACiB,YAAY,CACzBtB,kBAAkB,CAAC,YAAM;MACvB,SAAS;;MACT8E,KAAK,CAAC5D,OAAO,CAAC,UAAA6D,IAAA,EAAgD;QAAA,IAAAC,KAAA,GAAApF,cAAA,CAAAmF,IAAA;UAA9CE,eAAe,GAAAD,KAAA;UAAEE,WAAW,GAAAF,KAAA;UAAEG,UAAU,GAAAH,KAAA;QACtD,IAAMnC,MAAM,GAAGoC,eAAe,CAAAnD,KAAA,SAAAnC,kBAAA,CAAIuF,WAAW,EAAC;QAC9C,IAAIC,UAAU,EAAE;UACdlC,OAAO,CAACkC,UAAU,CAAC,CAACtC,MAAM,CAAC;QAC7B;MACF,CAAC,CAAC;MACFxB,cAAc,CAAC,CAAC;IAClB,CAAC,CACH,CAAC;EACH,CAAC,CAAC;AACJ;AAOA,OAAO,SAAS+D,sBAAsBA,CACpC7D,OAAiC,EACjC;EACA,OAAO,YAAoB;IACzB,SAAS;;IACTA,OAAO,CAAAO,KAAA,SAAAL,SAAQ,CAAC;IAChBJ,cAAc,CAAC,CAAC;EAClB,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}